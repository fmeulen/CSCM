"""
Conversion vector and matrix format
Example usage
    a =  reshape(1:6,2,3)
    vec2mat(mat2vec(a),2,3)-a
"""
mat2vec(x) = vec(x) # colunmwise filling

vec2mat(x,m,n) = reshape(x,m,n)

sigmoid(x) = exp(x)/(1+exp(x))

invlogit(x) = sigmoid.(x)/sum(sigmoid.(x))
#invlogit(x) = exp.(x)/sum(exp.(x))

extractind(w,i) = map(x->x[i],w)

indbin(x_,binx) = (x_>=binx[end]) ? error("bin does not exist") : findfirst(x -> x > x_, binx) -1  # look up in which bin x_ is located

graphlaplacian(m,n) = Matrix(lap(grid2(m,n))) + I/(m*n)^2


"""
Generate data for current status continuous mark model.
"""
function gendata(truedatagen, N, θ)  # θ is par for GaussianCopula copula
    t = sqrt.(rand(N))
    if truedatagen=="x+y"
        x = -0.5 .+ 0.5 *sqrt.(1 .+ 8*rand(N))
        y = -x .+ sqrt.(x.^2 .+ (2x .+ 1) .* rand(N))
    end
    if truedatagen=="uniform"
        x = rand(N)
        y = rand(N)
    end
    if truedatagen=="(3/8)(x2+y)"
        u = rand(N)
        x = (2u .+ sqrt.(4*u.^2 .+ 1)).^(1/3) .- abs.(2u .- sqrt.(4*u.^2 .+ 1)).^(1/3)
        y = -x.^2 + sqrt.(x.^4 .+ 4*(x.^2 .+ 1) .* rand(N))
    end
    if truedatagen=="GaussianCopula"
        out = rand(GaussianCopula(θ),N)
        x = out[:,1]
        y = out[:,2]
    end
    # find indices of case where x<t (y observed) and x>= t (y not observed)
    ind_yknown = findall(x.<t)
    ind_yunknown = findall(x.>=t)
    # So as available data we are given ind_yknown, ind_yunknown, t and y[ind_yknown]

    x, y, t, ind_yknown, ind_yunknown
end

function Ftrue(x,y,truedatagen, θ)  # θ is par for GaussianCopula copula
    if truedatagen=="uniform"
        out = x+y
    end
    if truedatagen=="x+y"
        out = 0.5*x^2*y + 0.5*x*y^2
    end
    if truedatagen=="(3/8)(x2+y)"
        out = (3/8)*(y*(x^3)/3 + 0.5*x*y^2)
    end
    if truedatagen=="GaussianCopula"
        th = θ
        @rput x
        @rput y
        @rput th
        R"""
            library(copula)
            cop = normalCopula(th,2)
            out = pCopula(c(x, y),cop)
        """
        @rget out
    end
    out
end

function ftrue(x,y,truedatagen, θ)  # θ is par for GaussianCopula copula
    if truedatagen=="uniform"
        out = 1
    end
    if truedatagen=="x+y"
        out = x+y
    end
    if truedatagen=="(3/8)(x2+y)"
        out = (3/8)*(x^2 + y)
    end
    if truedatagen=="GaussianCopula"
        th = θ
        @rput x
        @rput y
        @rput th
        R"""
            library(copula)
            cop = normalCopula(th,2)
            out = dCopula(c(x, y),cop)
        """
        @rget out
    end
    out
end

"""
Compute the true bin probabilities for data generated by 'truedatagen'.
Probabilities are stacked into a vector where the inner loop goes over the y-direction.
"""
function binprobtrue(binx,biny,truedatagen,θ)
    m,n = length(binx)-1, length(biny)-1
    out = Float64[]
    for i in 1:m
        for j in 1:n
            val = Ftrue(binx[i+1],biny[j+1], truedatagen,θ) -
                        Ftrue(binx[i+1],biny[j], truedatagen,θ) -
                        Ftrue(binx[i],biny[j+1], truedatagen,θ) +
                        Ftrue(binx[i],biny[j], truedatagen,θ)
            push!(out, val)
        end
    end
    out
end


"""
Compare bin probabilities in pweights to true bin probabilities computed using true datagen
"""
function write_binprobs(pest,truedatagen,binx,biny,titel,θ)
    m = length(binx)-1 ; n = length(biny)-1
    xx = repeat(binx[2:end],inner=n)
    yy = repeat(biny[2:end],outer=m)
    ptrue = binprobtrue(binx,biny,truedatagen,θ)  # true bin probabilities
    d = DataFrame(pest=pest, ptrue=ptrue, x=xx, y=yy)
    CSV.write("./out/"*titel*"binprob.csv",d)
    d
end



mutable struct censoringinfo
    fracarea  # keep track of fraction of bin areas
    ind   # corresponding indices
end

# Turing hierarchical model
@model GraphLaplacianModel(z,ci,L) = begin
    τ ~ InverseGamma(.1,.1)
    H ~ MvNormalCanon(L*τ)
    θ = invlogit(H)
    for k in eachindex(z)
        z[k] ~ Bernoulli(sum(θ[ci[k].ind].* ci[k].fracarea))
    end
end

"""
    t: observed times
    ind_yknown: vector of indices that correspond to those times in t where y is observed
    y: vector of observed marks (elements corresponding to times where the mark y is not observed can be specified arbitrarily,
    for example z zero)
    binx: bin grid in x direction
    biny: bin grid in y direction
    BI: number of samples considered burnIn
    sampler: sampler

    Returns:     iterates, Hiterates, θiterates, θpostmean
    Here 'iterates' contains all iterates, whereas for
    Hiterates, θiterates, θpostmean burnin samples have been removed
"""
function sample_graphlap(t,ind_yknown, y,binx,biny, ITER_GL, BI_GL; sampler=HMC(0.1, 5))
    binarea = (binx[2]-binx[1]) * (biny[2]-biny[1]) # the same for all bins
    NSAMPLE = length(t)
    zz = zeros(Int64,NSAMPLE)
    zz[ind_yknown] .= 1 # so if y is known z=1
    m = length(binx) - 1
    n = length(biny) - 1
    ci = Vector{censoringinfo}(undef,NSAMPLE)

    for k in 1:NSAMPLE
        it = indbin(t[k],binx)
        if zz[k]==1
            iy = indbin(y[k],biny)
            area = [ min(binx[i+1],t[k])-binx[i] for i in 1:it] * (biny[iy+1] - biny[iy])
            ind = [iy + ℓ*n for ℓ in 0:(it-1)]
        else
            area = [(binx[i+1]-max(t[k],binx[i])) * (biny[j+1] - biny[j])  for i in it:m for j in 1:n]
            ind = ((it-1)*n+1):(m*n)
        end
        ci[k] = censoringinfo(area/binarea,ind)
    end

    L = graphlaplacian(m,n) # graph Laplacian with τ=1
    model = GraphLaplacianModel(ones(Int8,NSAMPLE),ci,L)
    chn = Turing.sample(model, sampler,ITER_GL)
    # here also possible to use Gibbs sampling where tau and H are iteratively updated.

    iterates = chn.value[1:end,:,1]
    Hiterates = chn.value[BI_GL:end,1:m*n,1]
    θiterates = mapslices(invlogit, Hiterates,dims=2) # transform iterates back to θ
    θpostmean = vec(mean(θiterates,dims=1))
    iterates, Hiterates, θiterates, θpostmean
end
#------------------------------------------------


# functions for Dirichlet prior

mutable struct obs
    t::Float64
    ix::Int64
    iy::Int64
    it::Int64
    obstype::String
    area  # keep track of bin areas or lengths (in case y is known), needed for updating latent data
    indpairs  # only needed for case y is unknown
end

####### Initialise fulldata and counts

function sample_dir(t,ind_yknown, y,binx,biny, BI, ITER; priorscale = 0.1)
    m = length(binx) - 1
    n = length(biny) - 1
    counts = zeros(Int64,m,n)  # adjust at each iteration
    fulldata = Vector{obs}(undef,NSAMPLE)  # adjust at each iteration

    for k in 1:NSAMPLE
        it = indbin(t[k],binx)
        if k in ind_yknown
            ix = rand(1:it)
            iy = indbin(y[k],biny)
            obstype="yknown"
            area = [ min(binx[i+1],t[k])-binx[i] for i in 1:it]
            indpairs = 0
        else
            ix = rand(it:m)
            iy = rand(1:n)
            obstype="yunknown"
            area = [(binx[i+1]-max(t[k],binx[i])) * (biny[j+1] - biny[j])  for i in it:m for j in 1:n]
            indpairs =[ [i,j] for i in it:m for j in 1:n]
        end
        counts[ix,iy] +=1
        fulldata[k] = obs(t[k],ix,iy,it,obstype,area,indpairs)
    end

    priorθ = priorscale *  ones(m,n)

    θ = Vector{Matrix{Float64}}(undef,ITER) # save in each iteration

    ####### Data augmentation algorithm
    for iter in 1:ITER
        # Update weights
        θ[iter] = vec2mat( rand(Dirichlet(vec(counts+priorθ))) , m, n)

        # Update latent data
        for k in 1:NSAMPLE#  sample(1:n, div(n,2))#1:n
            ix_ = fulldata[k].ix;  iy_ = fulldata[k].iy; it_ = fulldata[k].it;
            t_ = fulldata[k].t
            obstype_ = fulldata[k].obstype
            area_ = fulldata[k].area

            counts[ix_,iy_] += -1
            if obstype_=="yknown"  # update ix, consider i in 1..it_,  j=iy_
                w = [θ[iter][i,iy_] for i in 1:it_] .*  area_
                ind = wsample(1:it_,w)
                counts[ind,iy_] += 1
                fulldata[k].ix = ind
            end
            if obstype_=="yunknown"  # update ix and iy, consinder i in it_..nbinx, j in 1..nbiny
                w = [θ[iter][i,j] for i in it_:m for j in 1:n] .* area_
                ind = wsample(fulldata[k].indpairs,w)
                counts[ind[1],ind[2]] += 1
                fulldata[k].ix = ind[1]
                fulldata[k].iy = ind[2]
            end
        end
        if mod(iter,50)==0
            println(iter)
        end
    end

    # compute average of weights
    θpostmean = mat2vec(mean(θ))
    θ, θpostmean
end
