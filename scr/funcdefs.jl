"""
Conversion vector and matrix format
Example usage
    a =  reshape(1:6,2,3)
    vec2mat(mat2vec(a),2,3)-a
"""
mat2vec(x) = vec(x) # colunmwise filling
 
vec2mat(x,m,n) = reshape(x,m,n)

sigmoid(x) = exp(x)/(1+exp(x))

invlogit(x) = sigmoid.(x)/sum(sigmoid.(x))
#invlogit(x) = exp.(x)/sum(exp.(x))

extractind(w,i) = map(x->x[i],w)

indbin(x_,binx) = (x_>=binx[end]) ? error("bin does not exist") : findfirst(x -> x > x_, binx) -1  # look up in which bin x_ is located

graphlaplacian(m,n) = Matrix(lap(grid2(m,n))) + I/(m*n)^2


"""
Generate data for current status continuous mark model.
"""
function gendata(truedatagen, N, θ)  # θ is par for GaussianCopula copula
    t = sqrt.(rand(N))
    if truedatagen=="x+y"
        x = -0.5 .+ 0.5 *sqrt.(1 .+ 8*rand(N))
        y = -x .+ sqrt.(x.^2 .+ (2x .+ 1) .* rand(N))
    end
    if truedatagen=="uniform"
        x = rand(N)
        y = rand(N)
    end
    if truedatagen=="(3/8)(x2+y)"
        u = rand(N)
        x = (2u .+ sqrt.(4*u.^2 .+ 1)).^(1/3) .- abs.(2u .- sqrt.(4*u.^2 .+ 1)).^(1/3)
        y = -x.^2 + sqrt.(x.^4 .+ 4*(x.^2 .+ 1) .* rand(N))
    end
    if truedatagen=="GaussianCopula"
        out = rand(GaussianCopula(θ),N)
        x = out[:,1]
        y = out[:,2]
    end
    # find indices of case where x<t (y observed) and x>= t (y not observed)
    ind_yknown = findall(x.<t)
    ind_yunknown = findall(x.>=t)
    # So as available data we are given ind_yknown, ind_yunknown, t and y[ind_yknown]

    x, y, t, ind_yknown, ind_yunknown
end

function Ftrue(x,y,truedatagen, θ)  # θ is par for GaussianCopula copula
    if truedatagen=="uniform"
        out = x+y
    end
    if truedatagen=="x+y"
        out = 0.5*x^2*y + 0.5*x*y^2
    end
    if truedatagen=="(3/8)(x2+y)"
        out = (3/8)*(y*(x^3)/3 + 0.5*x*y^2)
    end
    # if truedatagen=="GaussianCopula"
    #     if abs(x*y) <10^(-2)
    #         out = 0.0
    #     else
    #         out = max((x^(-θ)+y^(-θ)-1)^(-1/θ),0)
    #     end
    # end
    if truedatagen=="GaussianCopula"
        th = θ
        @rput x
        @rput y
        @rput th
        R"""
            library(copula)
            cop = normalCopula(th,2)
            out = pCopula(c(x, y),cop)
        """
        @rget out
    end
    out
end

function ftrue(x,y,truedatagen, θ)  # θ is par for GaussianCopula copula
    if truedatagen=="uniform"
        out = 1
    end
    if truedatagen=="x+y"
        out = x+y
    end
    if truedatagen=="(3/8)(x2+y)"
        out = (3/8)*(x^2 + y)
    end
    # if truedatagen=="GaussianCopula"
    #     if abs(x*y) <10^(-2)
    #         out = 0.0
    #     else
    #         #out = (θ+1) * (x^(-θ) + y^(-θ) -1)^(-1/θ-2)  * (x*y)^(-θ-1)
    #         logout = log(θ+1) - (θ^(-1) + 2)* log(x^(-θ) + y^(-θ) -1) - (θ+1)* (log(x) + log(y))
    #         out = exp(logout)
    #     end
    if truedatagen=="GaussianCopula"
        th = θ
        @rput x
        @rput y
        @rput th
        R"""
            library(copula)
            cop = normalCopula(th,2)
            out = dCopula(c(x, y),cop)
        """
        @rget out
    end
    out
end

"""
Compute the true bin probabilities for data generated by 'truedatagen'.
Probabilities are stacked into a vector where the inner loop goes over the y-direction.
"""
function binprobtrue(binx,biny,truedatagen,θ)
    m,n = length(binx)-1, length(biny)-1
    out = Float64[]
    for i in 1:m
        for j in 1:n
            val = Ftrue(binx[i+1],biny[j+1], truedatagen,θ) -
                        Ftrue(binx[i+1],biny[j], truedatagen,θ) -
                        Ftrue(binx[i],biny[j+1], truedatagen,θ) +
                        Ftrue(binx[i],biny[j], truedatagen,θ)
            push!(out, val)
        end
    end
    out
end

function denstrue(x,y,truedatagen,θ)
    out = Float64[]
    for i in eachindex(x)
        for j in eachindex(y)
            val = ftrue(x[i],y[j], truedatagen,θ)
            push!(out, val)
        end
    end
    out
end

function f_piecewise_constant(x,y,binx,biny,dweights)
    n = length(binx)-1
    ix = indbin(x,binx)
    iy = indbin(y,biny)
    dweights[(ix-1)*n + iy]
end

function dens_piecewise_constant(gridx,gridy,binx,biny,dweights)
    out = Float64[]
    for i in eachindex(gridx)
        for j in eachindex(gridy)
            val = f_piecewise_constant(gridx[i],gridy[j],binx,biny,dweights)
            push!(out, val)
        end
    end
    out
end


"""
Compare bin probabilities in pweights to true bin probabilities computed using treudatagen
"""
function prep_plotting_p(pest,truedatagen,binx,biny,titel,θ)
    m = length(binx)-1 ; n = length(biny)-1
    xx = repeat(binx[2:end],inner=n)
    yy = repeat(biny[2:end],outer=m)
    ptrue = binprobtrue(binx,biny,truedatagen,θ)  # true bin probabilities
    d = DataFrame(pest=pest, ptrue=ptrue, x=xx, y=yy)
    CSV.write("./out/"*titel*"binprob.csv",d)
    d
end

function plotting_p(d,titel;mincol_lim=-1,maxcol_lim=1)
    @rput d
    @rput titel
    @rput mincol_lim
    @rput maxcol_lim
    R"""
        library(ggplot2)
        library(tidyverse)
        theme_set(theme_light())
        ggplot(data=d,aes(x, y, fill=pest-ptrue)) + geom_tile() +
        scale_fill_gradient2(limits=c(mincol_lim, maxcol_lim))+
        ggtitle(paste0(titel," - bin probability error"))
        ggsave(paste0("./out/",titel,"_p.pdf"))
    """
    norm(d[:pest]-d[:ptrue])
end

"""
Compare estimated piecewise constant probability density function, specified via
dweights, to true density computed using treudatagen
"""
function prep_plotting_d(dweights,truedatagen,binx,biny, titel,θ ;gridN=200)
    # Asses error by binning for true pdf
    minx, maxx = extrema(binx)
    miny, maxy = extrema(biny)
    gridx = range(minx,stop=maxx-0.001,length=gridN)
    gridy = range(miny,stop=maxy-0.001,length=gridN)

    dest = dens_piecewise_constant(gridx,gridy,binx,biny,dweights)
    dtrue = denstrue(gridx,gridy,truedatagen,θ)

    d = DataFrame(dest=dest,dtrue=dtrue, x =repeat(gridx,inner=gridN), y=repeat(gridy,outer=gridN))
    CSV.write("./out/"*titel*"density.csv",d)
    d
end

function plotting_d(d, titel;mincol_lim=-1,maxcol_lim=1)
    @rput d
    @rput titel
    @rput mincol_lim
    @rput maxcol_lim
    R"""
        library(ggplot2)
        library(tidyverse)
        theme_set(theme_light())
        ggplot(data=d,aes(x, y, fill=dest-dtrue)) + geom_tile() +
                scale_fill_gradient2(limits=c(mincol_lim, maxcol_lim))+
        ggtitle(paste0(titel," - density error"))
        ggsave(paste0("./out/",titel,"_d.pdf"))
    """

    R"""
        library(ggplot2)
        library(tidyverse)
        theme_set(theme_light())
        ggplot(data=d,aes(x, y,z=dtrue)) +
            geom_tile(aes(fill=dtrue))+
            #stat_contour(bins=6,aes(x,y,z=dtrue), color="black", size=0.6)+
            scale_fill_gradient2(low="white", high="black")#+geom_contour(binwidth = 0.5)
            ggtitle("Data generating density")

        ggsave("./out/truedensitydensity.pdf")
    """

    norm(d[:dest]-d[:dtrue])
end

# Example with data from GaussianCopula copula

abstract type Copula
end

struct GaussianCopula <: Copula
    θ
end


"""
 rand(fam::GaussianCopula,n::Integer)

 simulate bivariate data from GaussianCopula family (returns 2 x n matrix so that each column contains an independent realisation)

 x=rand(GaussianCopula(2.0),5000)
"""
function Base.rand(fam::GaussianCopula,n::Integer)
    th = fam.θ
    @rput th
    @rput n
    R"""
        library(copula)
        cop=normalCopula(th,2)
        out = rCopula(n,copula = cop)
    """
    @rget out
    out
    # θ = fam.θ
    # res = zeros(2,n)
    # for i in 1:n
    #     U = rand()
    #     S = U^(-θ) - 1
    #     res[:,i] = [U, ((1+S) * rand()^(-θ/(1+θ)) - S)^(-1/θ)]
    # end
    # res
end

# x=rand(GaussianCopula(2.0),5000)
# @rput x
# R"""
#     plot(x[1,],x[2,])
# """




function plotting(θpostmean_dir,truedatagen,binx,biny,binarea,θcopula, N)
    df_error_dir_p = prep_plotting_p(θpostmean_dir,truedatagen,binx,biny,"Dirichlet",θcopula)
    df_error_gl_p = prep_plotting_p(θpostmean_gl,truedatagen,binx,biny,"graphLaplacian",θcopula)
    # set colour limits
    minl, maxl = extrema(  hcat(df_error_dir_p.pest-df_error_dir_p.ptrue,df_error_gl_p.pest-df_error_gl_p.ptrue))
    # make plots
    error_dir_p = plotting_p(df_error_dir_p,"Dirichlet";mincol_lim=minl,maxcol_lim=maxl)
    error_gl_p = plotting_p(df_error_gl_p,"graphLaplacian";mincol_lim=minl,maxcol_lim=maxl)

    # similarly for densities
    df_error_dir_d = prep_plotting_d(θpostmean_dir/binarea,truedatagen,binx,biny, "Dirichlet",θcopula)
    df_error_gl_d = prep_plotting_d(θpostmean_gl/binarea,truedatagen,binx,biny, "graphLaplacian",θcopula)
    minl, maxl = extrema(  hcat(df_error_dir_d.dest-df_error_dir_d.dtrue,df_error_gl_d.dest-df_error_gl_d.dtrue))
    error_dir_d = plotting_d(df_error_dir_d, "Dirichlet";mincol_lim=minl,maxcol_lim=maxl)
    error_gl_d = plotting_d(df_error_gl_d, "graphLaplacian";mincol_lim=minl,maxcol_lim=maxl)
    error_dir_p,  error_gl_p, error_dir_d,  error_gl_d
end


#----------- code for graph laplacian priorscale
"""
Compute inverse graph Laplacian, with power parameter (ρ) fixed to one.
"""
function invgraphlaplacian(m,n,τ) # order columnwise
    kol1 = [2; fill(3,n-2); 2]
    diagD = vcat(kol1, repeat(kol1 .+ 1,m-2),kol1)
    k = m * n
    L = diagm(0=>diagD .+ 1/k^2, 1=> fill(-1,k-1), -1 => fill(-1,k-1))   # graph Laplacian matrix
    Σ = τ^(-1) * inv(L)
    (Σ+Σ')/2
end

mutable struct censoringinfo
    fracarea  # keep track of fraction of bin areas
    ind   # corresponding indices
end

# Turing hierarchical model
@model GraphLaplacianModel(z,ci,L) = begin
    τ ~ InverseGamma(.1,.1)
    H ~ MvNormalCanon(L*τ)
    θ = invlogit(H)
    for k in eachindex(z)
        z[k] ~ Bernoulli(sum(θ[ci[k].ind].* ci[k].fracarea))
    end
end

"""
    t: observed times
    ind_yknown: vector of indices that correspond to those times in t where y is observed
    y: vector of observed marks (elements corresponding to times where the mark y is not observed can be specified arbitrarily,
    for example z zero)
    binx: bin grid in x direction
    biny: bin grid in y direction
    BI: number of samples considered burnIn
    sampler: sampler

    Returns:     iterates, Hiterates, θiterates, θpostmean
    Here 'iterates' contains all iterates, whereas for
    Hiterates, θiterates, θpostmean burnin samples have been removed
"""
function sample_graphlap(t,ind_yknown, y,binx,biny, BI; sampler=HMC(10, 0.1, 5))
    binarea = (binx[2]-binx[1]) * (biny[2]-biny[1]) # the same for all bins
    NSAMPLE = length(t)
    zz = zeros(Int64,NSAMPLE)
    zz[ind_yknown] .= 1 # so if y is known z=1
    m = length(binx) - 1
    n = length(biny) - 1
    ci = Vector{censoringinfo}(undef,NSAMPLE)

    for k in 1:NSAMPLE
        it = indbin(t[k],binx)
        if zz[k]==1
            iy = indbin(y[k],biny)
            area = [ min(binx[i+1],t[k])-binx[i] for i in 1:it] * (biny[iy+1] - biny[iy])
            ind = [iy + ℓ*n for ℓ in 0:(it-1)]
        else
            area = [(binx[i+1]-max(t[k],binx[i])) * (biny[j+1] - biny[j])  for i in it:m for j in 1:n]
            ind = ((it-1)*n+1):(m*n)
        end
        ci[k] = censoringinfo(area/binarea,ind)
    end

    L = graphlaplacian(m,n) # graph Laplacian with τ=1
    model = GraphLaplacianModel(ones(Int8,NSAMPLE),ci,L)
    chn = Turing.sample(model, sampler)
    # here also possible to use Gibbs sampling where tau and H are iteratively updated.

    iterates = chn.value[1:end,:,1]
    Hiterates = chn.value[BI:end,1:m*n,1]
    θiterates = mapslices(invlogit, Hiterates,dims=2) # transform iterates back to θ
    θpostmean = vec(mean(θiterates,dims=1))
    iterates, Hiterates, θiterates, θpostmean
end
#------------------------------------------------


# functions for Dirichlet prior

mutable struct obs
    t::Float64
    ix::Int64
    iy::Int64
    it::Int64
    obstype::String
    area  # keep track of bin areas or lengths (in case y is known), needed for updating latent data
    indpairs  # only needed for case y is unknown
end

####### Initialise fulldata and counts

function sample_dir(t,ind_yknown, y,binx,biny, BI, ITER; priorscale = 0.1)
    m = length(binx) - 1
    n = length(biny) - 1
    counts = zeros(Int64,m,n)  # adjust at each iteration
    fulldata = Vector{obs}(undef,NSAMPLE)  # adjust at each iteration

    for k in 1:NSAMPLE
        it = indbin(t[k],binx)
        if k in ind_yknown
            ix = rand(1:it)
            iy = indbin(y[k],biny)
            obstype="yknown"
            area = [ min(binx[i+1],t[k])-binx[i] for i in 1:it]
            indpairs = 0
        else
            ix = rand(it:m)
            iy = rand(1:n)
            obstype="yunknown"
            area = [(binx[i+1]-max(t[k],binx[i])) * (biny[j+1] - biny[j])  for i in it:m for j in 1:n]
            indpairs =[ [i,j] for i in it:m for j in 1:n]
        end
        counts[ix,iy] +=1
        fulldata[k] = obs(t[k],ix,iy,it,obstype,area,indpairs)
    end

    priorθ = priorscale *  ones(m,n)

    θ = Vector{Matrix{Float64}}(undef,ITER) # save in each iteration

    ####### Data augmentation algorithm
    for iter in 1:ITER
        # Update weights
        θ[iter] = vec2mat( rand(Dirichlet(vec(counts+priorθ))) , m, n)

        # Update latent data
        for k in 1:NSAMPLE#  sample(1:n, div(n,2))#1:n
            ix_ = fulldata[k].ix;  iy_ = fulldata[k].iy; it_ = fulldata[k].it;
            t_ = fulldata[k].t
            obstype_ = fulldata[k].obstype
            area_ = fulldata[k].area

            counts[ix_,iy_] += -1
            if obstype_=="yknown"  # update ix, consider i in 1..it_,  j=iy_
                w = [θ[iter][i,iy_] for i in 1:it_] .*  area_
                ind = wsample(1:it_,w)
                counts[ind,iy_] += 1
                fulldata[k].ix = ind
            end
            if obstype_=="yunknown"  # update ix and iy, consinder i in it_..nbinx, j in 1..nbiny
                w = [θ[iter][i,j] for i in it_:m for j in 1:n] .* area_
                ind = wsample(fulldata[k].indpairs,w)
                counts[ind[1],ind[2]] += 1
                fulldata[k].ix = ind[1]
                fulldata[k].iy = ind[2]
            end
        end
        if mod(iter,50)==0
            println(iter)
        end
    end

    # compute average of weights
    θpostmean = mat2vec(mean(θ))
    θ, θpostmean
end
