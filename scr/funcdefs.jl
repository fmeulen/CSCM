"""
Conversion vector and matrix format
Example usage
    a =  reshape(1:6,2,3)
    vec2mat(mat2vec(a),2,3)-a
"""
mat2vec(x) = vec(x) # colunmwise filling

vec2mat(x,m,n) = reshape(x,m,n)

invlogit(x) = exp.(x)/sum(exp.(x))

extractind(w,i) = map(x->x[i],w)

indbin(x_,binx) = (x_>=binx[end]) ? error("bin does not exist") : findfirst(x -> x > x_, binx) -1  # look up in which bin x_ is located

graphlaplacian(m,n) = Matrix(lap(grid2(m,n))) + I/(m*n)^2

"""
Compute inverse graph Laplacian, with power parameter (ρ) fixed to one.
"""
function invgraphlaplacian(m,n,τ) # order columnwise
    kol1 = [2; fill(3,n-2); 2]
    diagD = vcat(kol1, repeat(kol1 .+ 1,m-2),kol1)
    k = m * n
    L = diagm(0=>diagD .+ 1/k^2, 1=> fill(-1,k-1), -1 => fill(-1,k-1))   # graph Laplacian matrix
    Σ = τ^(-1) * inv(L)
    (Σ+Σ')/2
end

"""
Generate data for current status continuous mark model.
"""
function gendata(case, N)
    t = sqrt.(rand(N))
    if case=="x+y"
        x = -0.5 .+ 0.5 *sqrt.(1 .+ 8*rand(N))
        y = -x .+ sqrt.(x.^2 .+ (2x .+ 1) .* rand(N))
    end
    if case=="uniform"
        x = rand(N)
        y = rand(N)
    end
    if case=="(3/8)(x2+y)"
        u = rand(N)
        x = (2u .+ sqrt.(4*u.^2 .+ 1)).^(1/3) .- abs.(2u .- sqrt.(4*u.^2 .+ 1)).^(1/3)
        y = -x.^2 + sqrt.(x.^4 .+ 4*(x.^2 .+ 1) .* rand(N))
    end
    # find indices of case where x<t (y observed) and x>= t (y not observed)
    ind_yknown = findall(x.<t)
    ind_yunknown = findall(x.>=t)
    # So as available data we are given ind_yknown, ind_yunknown, t and y[ind_yknown]

    x, y, t, ind_yknown, ind_yunknown
end

function Ftrue(x,y,truedatagen)
    if truedatagen=="uniform"
        return(x*y)
    end
    if truedatagen=="x+y"
        return(0.5*x^2*y + 0.5*x*y^2)
    end
    if truedatagen=="(3/8)(x2+y)"
        return((3/8)*(y*(x^3)/3 + 0.5*x*y^2))
    end
end

function ftrue(x,y,truedatagen)
    if truedatagen=="uniform"
        return(1)
    end
    if truedatagen=="x+y"
        return(x+y)
    end
    if truedatagen=="(3/8)(x2+y)"
        return((3/8)*(x^2 + y))
    end
end

"""
Compute the true bin probabilities for data generated by 'truedatagen'.
Probabilities are stacked into a vector where the inner loop goes over the y-direction.
"""
function binprobtrue(binx,biny,truedatagen)
    m,n = length(binx)-1, length(biny)-1
    out = Float64[]
    for i in 1:m
        for j in 1:n
            val = Ftrue(binx[i+1],biny[j+1], truedatagen) -
                        Ftrue(binx[i+1],biny[j], truedatagen) -
                        Ftrue(binx[i],biny[j+1], truedatagen) +
                        Ftrue(binx[i],biny[j], truedatagen)
            push!(out, val)
        end
    end
    out
end

function denstrue(x,y,truedatagen)
    out = Float64[]
    for i in eachindex(x)
        for j in eachindex(y)
            val = ftrue(x[i],y[j], truedatagen)
            push!(out, val)
        end
    end
    out
end

function f_piecewise_constant(x,y,binx,biny,dweights)
    n = length(binx)-1
    ix = indbin(x,binx)
    iy = indbin(y,biny)
    dweights[(ix-1)*n + iy]
end

function dens_piecewise_constant(gridx,gridy,binx,biny,dweights)
    out = Float64[]
    for i in eachindex(gridx)
        for j in eachindex(gridy)
            val = f_piecewise_constant(gridx[i],gridy[j],binx,biny,dweights)
            push!(out, val)
        end
    end
    out
end


"""
Compare bin probabilities in pweights to true bin probabilities computed using treudatagen
"""
function prep_plotting_p(pest,truedatagen,binx,biny,titel)
    m = length(binx)-1 ; n = length(biny)-1
    xx = repeat(binx[2:end],inner=n)
    yy = repeat(biny[2:end],outer=m)
    ptrue = binprobtrue(binx,biny,truedatagen)  # true bin probabilities
    d = DataFrame(pest=pest, ptrue=ptrue, x=xx, y=yy)
    CSV.write("./out/"*titel*"binprob.csv",d)
    d
end

function plotting_p(d,titel;mincol_lim=-1,maxcol_lim=1)
    @rput d
    @rput titel
    @rput mincol_lim
    @rput maxcol_lim
    R"""
        library(ggplot2)
        library(tidyverse)
        ggplot(data=d,aes(x, y, fill=pest-ptrue)) + geom_tile() +
        scale_fill_gradient2(limits=c(mincol_lim, maxcol_lim))+
        ggtitle(paste0(titel," - bin probability error"))
        ggsave(paste0("./out/",titel,"_p.pdf"))
    """
    norm(d[:pest]-d[:ptrue])
end

"""
Compare estimated piecewise constant probability density function, specified via
dweights, to true density computed using treudatagen
"""
function prep_plotting_d(dweights,truedatagen,binx,biny, titel;gridN=200)
    # Asses error by binning for true pdf
    minx, maxx = extrema(binx)
    miny, maxy = extrema(biny)
    gridx = range(minx,stop=maxx-0.001,length=gridN)
    gridy = range(miny,stop=maxy-0.001,length=gridN)

    dest = dens_piecewise_constant(gridx,gridy,binx,biny,dweights)
    dtrue = denstrue(gridx,gridy,truedatagen)

    d = DataFrame(dest=dest,dtrue=dtrue, x =repeat(gridx,inner=gridN), y=repeat(gridy,outer=gridN))
    CSV.write("./out/"*titel*"density.csv",d)
    d
end

function plotting_d(d, titel;mincol_lim=-1,maxcol_lim=1)
    @rput d
    @rput titel
    @rput mincol_lim
    @rput maxcol_lim
    R"""
        library(ggplot2)
        library(tidyverse)
        ggplot(data=d,aes(x, y, fill=dest-dtrue)) + geom_tile() +
                scale_fill_gradient2(limits=c(mincol_lim, maxcol_lim))+
        ggtitle(paste0(titel," - density error"))
        ggsave(paste0("./out/",titel,"_d.pdf"))
    """

    R"""
        library(ggplot2)
        library(tidyverse)
        ggplot(data=d,aes(x, y, fill=dtrue)) + geom_tile() +
            scale_fill_gradient2(limits=c(mincol_lim, maxcol_lim))+
        ggtitle("Data generating density")
        ggsave("./out/truedensitydensity.pdf")
    """

    norm(d[:dest]-d[:dtrue])
end
