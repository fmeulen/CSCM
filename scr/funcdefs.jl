"""
Conversion vector and matrix format
Example usage
    a =  reshape(1:6,2,3)
    vec2mat(mat2vec(a),2,3)-a
"""
mat2vec(x) = vec(x) # colunmwise filling
vec2mat(x,m,n) = reshape(x,m,n)

extractind(w,i) = map(x -> x[i],w)
indbin(x_,binx) = (x_>=binx[end]) ? error("bin does not exist") : findfirst(x -> x > x_, binx) -1  # look up in which bin x_ is located


"""
    gendata(truedatagen, N)

Generate data for current status continuous mark model.
"""
function gendata(truedatagen, N)  # θ is par for GaussianCopula copula
    t = sqrt.(rand(N))
    if truedatagen=="x+y"
        x = -0.5 .+ 0.5 *sqrt.(1 .+ 8*rand(N))
        y = -x .+ sqrt.(x.^2 .+ (2x .+ 1) .* rand(N))
    end
    if truedatagen=="uniform"
        x = rand(N)
        y = rand(N)
    end
    if truedatagen=="(3/8)(x2+y)"
        u = rand(N)
        x = (2u .+ sqrt.(4*u.^2 .+ 1)).^(1/3) .- abs.(2u .- sqrt.(4*u.^2 .+ 1)).^(1/3)
        y = -x.^2 + sqrt.(x.^4 .+ 4*(x.^2 .+ 1) .* rand(N))
    end
    if truedatagen=="multimodal"
        r = [Beta(3.0, 4.0),  Beta(1.0, 5.0), Beta(5.0, 1.0)]
        rr(x) = Beta(1.0+x, 6.0*(2.0-x))
        x = rand(r[1], N)
        y = zeros(N)
        for i ∈ 1:N
            xi = x[i]
            y[i] = rand(rr(xi))
        end
    end
    # find indices of case where x<t (y observed) and x>= t (y not observed)
    ind_yknown = findall(x.<t)
    ind_yunknown = findall(x.>=t)
    # So as available data we are given ind_yknown, ind_yunknown, t and y[ind_yknown]

    x, y, t, ind_yknown, ind_yunknown
end

function Ftrue(x,y,truedatagen)
    if truedatagen=="uniform"
        out = x+y
    end
    if truedatagen=="x+y"
        out = 0.5*x^2*y + 0.5*x*y^2
    end
    if truedatagen=="(3/8)(x2+y)"
        out = (3/8)*(y*(x^3)/3 + 0.5*x*y^2)
    end
    if truedatagen=="multimodal"
        r = [Beta(3.0, 4.0),  Beta(10.0, 50.0), Beta(150.0, 50.0)]
        rr(x) = Beta(1.0+x, 6.0*(2.0-x))
        out = cdf(r[1], x) * cdf(rr(x),y)
        #out *= 0.5*cdf(r[2],y) + 0.5*cdf(r[3],y)
    end
    out
end

# function ftrue(x,y,truedatagen)
#     if truedatagen=="uniform"
#         out = 1
#     end
#     if truedatagen=="x+y"
#         out = x+y
#     end
#     if truedatagen=="(3/8)(x2+y)"
#         out = (3/8)*(x^2 + y)
#     end
#     out
# end

"""
Compute the true bin probabilities for data generated by 'truedatagen'.
Probabilities are stacked into a vector where the inner loop goes over the y-direction.
"""
function binprobtrue(binx,biny,truedatagen)
    m,n = length(binx)-1, length(biny)-1
    out = Float64[]
    for i in 1:m
        for j in 1:n
            val = Ftrue(binx[i+1],biny[j+1], truedatagen) -
                        Ftrue(binx[i+1],biny[j], truedatagen) -
                        Ftrue(binx[i],biny[j+1], truedatagen) +
                        Ftrue(binx[i],biny[j], truedatagen)
            push!(out, val)
        end
    end
    out
end


"""
Compare bin probabilities in pweights to true bin probabilities computed using true datagen
"""
function θtrue(truedatagen,binx,biny)
    m = length(binx)-1 ; n = length(biny)-1
    xx = repeat(binx[2:end],inner=n)
    yy = repeat(biny[2:end],outer=m)
    θ0 = binprobtrue(binx,biny,truedatagen)
    θ0, xx, yy
end
