"""
Conversion vector and matrix format
Example usage
    a =  reshape(1:6,2,3)
    vec2mat(mat2vec(a),2,3)-a
"""
mat2vec(x) = vec(x) # colunmwise filling
vec2mat(x,m,n) = reshape(x,m,n)

extractind(w,i) = map(x->x[i],w)
indbin(x_,binx) = (x_>=binx[end]) ? error("bin does not exist") : findfirst(x -> x > x_, binx) -1  # look up in which bin x_ is located


"""
    gendata(truedatagen, N, θ)

Generate data for current status continuous mark model.
"""
function gendata(truedatagen, N, θ)  # θ is par for GaussianCopula copula
    t = sqrt.(rand(N))
    if truedatagen=="x+y"
        x = -0.5 .+ 0.5 *sqrt.(1 .+ 8*rand(N))
        y = -x .+ sqrt.(x.^2 .+ (2x .+ 1) .* rand(N))
    end
    if truedatagen=="uniform"
        x = rand(N)
        y = rand(N)
    end
    if truedatagen=="(3/8)(x2+y)"
        u = rand(N)
        x = (2u .+ sqrt.(4*u.^2 .+ 1)).^(1/3) .- abs.(2u .- sqrt.(4*u.^2 .+ 1)).^(1/3)
        y = -x.^2 + sqrt.(x.^4 .+ 4*(x.^2 .+ 1) .* rand(N))
    end
    if truedatagen=="GaussianCopula"
        out = rand(GaussianCopula(θ),N)
        x = out[:,1]
        y = out[:,2]
    end
    # find indices of case where x<t (y observed) and x>= t (y not observed)
    ind_yknown = findall(x.<t)
    ind_yunknown = findall(x.>=t)
    # So as available data we are given ind_yknown, ind_yunknown, t and y[ind_yknown]

    x, y, t, ind_yknown, ind_yunknown
end

function Ftrue(x,y,truedatagen, θ)  # θ is par for GaussianCopula copula
    if truedatagen=="uniform"
        out = x+y
    end
    if truedatagen=="x+y"
        out = 0.5*x^2*y + 0.5*x*y^2
    end
    if truedatagen=="(3/8)(x2+y)"
        out = (3/8)*(y*(x^3)/3 + 0.5*x*y^2)
    end
    if truedatagen=="GaussianCopula"
        th = θ
        @rput x
        @rput y
        @rput th
        R"""
            library(copula)
            cop = normalCopula(th,2)
            out = pCopula(c(x, y),cop)
        """
        @rget out
    end
    out
end

function ftrue(x,y,truedatagen, θ)  # θ is par for GaussianCopula copula
    if truedatagen=="uniform"
        out = 1
    end
    if truedatagen=="x+y"
        out = x+y
    end
    if truedatagen=="(3/8)(x2+y)"
        out = (3/8)*(x^2 + y)
    end
    if truedatagen=="GaussianCopula"
        th = θ
        @rput x
        @rput y
        @rput th
        R"""
            library(copula)
            cop = normalCopula(th,2)
            out = dCopula(c(x, y),cop)
        """
        @rget out
    end
    out
end

"""
Compute the true bin probabilities for data generated by 'truedatagen'.
Probabilities are stacked into a vector where the inner loop goes over the y-direction.
"""
function binprobtrue(binx,biny,truedatagen,θ)
    m,n = length(binx)-1, length(biny)-1
    out = Float64[]
    for i in 1:m
        for j in 1:n
            val = Ftrue(binx[i+1],biny[j+1], truedatagen,θ) -
                        Ftrue(binx[i+1],biny[j], truedatagen,θ) -
                        Ftrue(binx[i],biny[j+1], truedatagen,θ) +
                        Ftrue(binx[i],biny[j], truedatagen,θ)
            push!(out, val)
        end
    end
    out
end


"""
Compare bin probabilities in pweights to true bin probabilities computed using true datagen
"""
function write_binprobs(pest,truedatagen,binx,biny,titel,θ)
    m = length(binx)-1 ; n = length(biny)-1
    xx = repeat(binx[2:end],inner=n)
    yy = repeat(biny[2:end],outer=m)
    ptrue = binprobtrue(binx,biny,truedatagen,θ)  # true bin probabilities
    d = DataFrame(pest=pest, ptrue=ptrue, x=xx, y=yy)
    CSV.write("./out/"*titel*"binprob.csv",d)
    d
end
