"""
Conversion vector and matrix format
Example usage
    a =  reshape(1:6,2,3)
    vec2mat(mat2vec(a),2,3)-a
"""
mat2vec(x) = vec(x) # colunmwise filling

vec2mat(x,m,n) = reshape(x,m,n)

invlogit(x) = exp.(x)/sum(exp.(x))

extractind(w,i) = map(x->x[i],w)

indbin(x_,binx) = (x_>=binx[end]) ? error("bin does not exist") : findfirst(x -> x > x_, binx) -1  # look up in which bin x_ is located

"""
Compute inverse graph Laplacian, with power parameter (ρ) fixed to one.
"""
function invgraphlaplacian(m,n,τ) # order columnwise
    kol1 = [2; fill(3,n-2); 2]
    diagD = vcat(kol1, repeat(kol1 .+ 1,m-2),kol1)
    k = m * n
    L = diagm(0=>diagD .+ 1/k^2, 1=> fill(-1,k-1), -1 => fill(-1,k-1))   # graph Laplacian matrix
    Σ = τ^(-1) * inv(L)
    (Σ+Σ')/2
end

function Ftrue(x,y,truedatagen)
    if truedatagen=="uniform"
        return(x*y)
    end
    if truedatagen=="x+y"
        return(0.5*x^2*y + 0.5*x*y^2)
    end
    if truedatagen=="(3/8)(x2+y)"
        return((3/8)*(y*(x^3)/3 + 0.5*x*y^2))
    end
end

"""
Compute the true bin probabilities for data generated by 'truedatagen'.
Probabilities are stacked into a vector where the inner loop goes over the y-direction.
"""
function binprobtrue(binx,biny,truedatagen)
    m,n = length(binx)-1, length(biny)-1
    out = Float64[]
    for i in 1:m
        for j in 1:n
            val = Ftrue(binx[i+1],biny[j+1], truedatagen) -
                        Ftrue(binx[i+1],biny[j], truedatagen) -
                        Ftrue(binx[i],biny[j+1], truedatagen) +
                        Ftrue(binx[i],biny[j], truedatagen)
            push!(out, val)
        end
    end
    out
end

"""
Generate data for current status continuous mark model.
"""
function gendata(case, N)
    if case=="x+y"
        x = -0.5 .+ 0.5 *sqrt.(1 .+ 8*rand(N))
        y = -x .+ sqrt.(x.^2 .+ (2x .+ 1) .* rand(N))
        t = sqrt.(rand(N))  # what we wish
    end
    if case=="uniform"
        x = rand(N)
        y = rand(N)
        t = rand(N)
    end
    if case=="(3/8)(x2+y)"
        u = rand(N)
        x = (2u .+ sqrt.(4*u.^2 .+ 1)).^(1/3) .- abs.(2u .- sqrt.(4*u.^2 .+ 1)).^(1/3)
        y = -x.^2 + sqrt.(x.^4 .+ 4*(x.^2 .+ 1) .* rand(N))
        t = sqrt.(rand(N))  # what we wish
    end
    # find indices of case where x<t (y observed) and x>= t (y not observed)
    ind_yknown = findall(x.<t)
    ind_yunknown = findall(x.>=t)
    # So as available data we are given ind_yknown, ind_yunknown, t and y[ind_yknown]

    x, y, t, ind_yknown, ind_yunknown
end


"""
Evaluate cdf of piecewise constant density in point (x,y), when the values on the bins are contained in the matrix w, and
the grid specifying the bins is given by binx (horizontal direction) and biny (vertical direction)

Implementation can be made more efficient, but probably not worth the effort.
"""
function cdf_(x,y,w,binx,biny)  # weights correspond to density in bins
    ix = indbin(x,binx)
    iy = indbin(y,biny)
    out = (x-binx[ix])*(y-biny[iy])*w[ix,iy]
    for i in 1:ix-1
        out += (binx[i+1]-binx[i]) * (y-biny[iy])*w[i,iy]
    end
    for j in 1:iy-1
        out += (x-binx[ix]) * (biny[j+1]-biny[j])*w[ix,j]
    end
    for i in 1:ix-1, j in 1:iy-1
        out += (binx[i+1]-binx[i])*(biny[j+1]-biny[j])*w[i,j]
    end
    out
end



function contourplot(weights, truedatagen; titel="Contour plot", gridN=200,binx=binx,biny=biny) # weights correspond to density in bins
    minx, maxx = extrema(binx)
    miny, maxy = extrema(biny)
    gridx = range(minx,stop=maxx-0.001,length=gridN)
    gridy = range(miny,stop=maxy-0.001,length=gridN)
    # gridF =[cdf_(gridx[i],gridy[j],weights,binx,biny) for j in 1:gridN for i in 1:gridN]
    # gridFᵒ = [Ftrue(gridx[i],gridy[j],truedatagen)  for j in 1:gridN for i in 1:gridN]

    gridF =[cdf_(gridx[i],gridy[j],weights,binx,biny)  for i in 1:gridN  for j in 1:gridN]
    gridFᵒ = [Ftrue(gridx[i],gridy[j],truedatagen)   for i in 1:gridN  for j in 1:gridN] # this works fine

    xxgrid = repeat(gridx,inner=gridN)
    yygrid = repeat(gridy,outer=gridN)
    leveldf = DataFrame(x=xxgrid,y=yygrid, posteriormean=gridF, datagenerating=gridFᵒ)

    @rput leveldf
    @rput titel
    R"""
        library(ggplot2)
        library(tidyverse)
        b<- c(0.01,0.05,seq(0.1:1.0,by=0.1))

        d <- leveldf %>% gather(key= curveID, value=z, posteriormean, datagenerating)
        d %>% ggplot(aes(x=x,y=y,z=z,colour=curveID,linetype=curveID)) + stat_contour(breaks=b, size=1.5) +
        theme(legend.position="bottom")+ggtitle(titel) #+theme_minimal()
        ggsave(paste0(titel,".pdf"))
    """
end

function plotting(pweights,truedatagen,binarea,binx,biny,titel1,titel2)
    m = length(binx)-1 ; n = length(biny)-1
    xx = repeat(binx[2:end],inner=n)
    yy = repeat(biny[2:end],outer=m)
    wtrue = binprobtrue(binx,biny,truedatagen)
    d = DataFrame(w=pweights, wtrue=wtrue, x=xx, y=yy)
    CSV.write("./out/"*titel1*".csv",d)
    @rput d
    @rput titel1
    @rput titel2
    R"""
        library(ggplot2)
        library(tidyverse)
        ggplot(data=d,aes(x, y, fill=w-wtrue)) + geom_tile() + ggtitle(titel1)
        ggsave(paste0(titel1,".pdf"))
    """
    contourplot(vec2mat(pweights/binarea,m,n), truedatagen;titel=titel2)
end
